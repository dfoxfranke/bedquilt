#![allow(clippy::too_many_arguments)]
//! Functions for concisely constructing items.
//! 
//! Everything here is just a trivial wrapper around various enum variants, but
//! using it will make your code-generation code much more readable.
//!
//! * To construct a function header item: use [`fnhead_local`] or
//!   [`fnhead_stack`].
//! * To construct a load operand: use [`pop`], [`imm`], [`uimm`], [`imml`],
//!   [`imml_off`], [`derefl`], [`derefl_off`], [`lloc`] or one of the reimports
//!   [`f32_to_imm`], [`f64_to_imm`], or [`load_local`].
//! * To construct a store operand: use [`push`], [`discard`], [`storel`],
//!   [`storel_off`] [`sloc`] or the reimport [`store_local`].
//! * To construct an instruction item: use the function named for the
//!   instruction, except that `mod` is [`modulus`] and `return` is [`ret`] to
//!   avoid colliding with Rust keywords. Branch instructions, for their branch
//!   target operand, just take an `L` rather than a `LoadOperand<L>`. 
//! * To construct a string or blob: use [`mystery_string`], [`utf32_string`],
//!   [`compressed_string`], or [`blob`].
//! * To construct a label item: use [`label`] or [`label_off`].
//! * To construct an alignment item: use [`align`].
//! * To construct a decoding table item: use [`decoding_table`].
//! * To construct a zero-item: use [`zspace`] or [`zalign`].
//!
//! Item constructors return a pair `(Option<L>, Item<L>)` in which the option
//! is `None`. To add a label, call `.label(l)` on it via the [`AddLabel`]
//! trait. Likewise goes for zero-item constructors.

// The instruction constructors were generated by a Python script, because that
// was easier than a one-off proc macro. The source to the script is in comments
// at the bottom of the module.

use crate::{cast::CastSign, DecodeNode};
pub use crate::{f32_to_imm, f64_to_imm, load_local, store_local};
use crate::{
    CallingConvention, Instr, Item, LoadOperand, MysteryString, StoreOperand, Utf32String, ZeroItem,
};

use bytes::Bytes;

/// Add a label to an item.
///
/// Call `.label(l)` on an `(Option<L>, Item<L>)` pair to change the
/// first part of the tuple to `Some(l)`.
pub trait AddLabel {
    /// The type of label operated upon.
    type Label;

    /// Add the given label.
    fn label(self, label: Self::Label) -> Self;
}

impl<L> AddLabel for (Option<L>, Item<L>) {
    type Label = L;
    fn label(self, label: L) -> Self {
        (Some(label), self.1)
    }
}

impl<L> AddLabel for (Option<L>, ZeroItem) {
    type Label = L;
    fn label(self, label: L) -> Self {
        (Some(label), self.1)
    }
}

/// Constructs a function header item with the `ArgsInLocals` calling convention.
pub fn fnhead_local<L>(nlocals: u32) -> (Option<L>, Item<L>) {
    (None, Item::FnHeader(CallingConvention::ArgsInLocals, nlocals))
}

/// Constructs a function header item with the `ArgsOnStack` calling convention.
pub fn fnhead_stack<L>(nlocals: u32) -> (Option<L>, Item<L>) {
    (None, Item::FnHeader(CallingConvention::ArgsOnStack, nlocals))
}

/// Constructs a load operand that pops from the stack.
pub fn pop<L>() -> LoadOperand<L> {
    LoadOperand::Pop
}

/// Constructs an immediate load operand.
pub fn imm<L>(x: i32) -> LoadOperand<L> {
    LoadOperand::Imm(x)
}

/// Constructs an unsigned immediate load operand.
pub fn uimm<L>(x: u32) -> LoadOperand<L> {
    LoadOperand::Imm(x.cast_sign())
}

/// Constructs an immedate load operand from a label.
pub fn imml<L>(x: L) -> LoadOperand<L> {
    LoadOperand::ImmLabel(x, 0)
}

/// Constructs an immedate load operand from a label and offset.
pub fn imml_off<L>(x: L, offset: i32) -> LoadOperand<L> {
    LoadOperand::ImmLabel(x, offset)
}

/// Constructs a load operand which derefernces a label.
pub fn derefl<L>(x: L) -> LoadOperand<L> {
    LoadOperand::DerefLabel(x, 0)
}

/// Constructs a load operand which derefernces a label and offset.
pub fn derefl_off<L>(x: L) -> LoadOperand<L> {
    LoadOperand::DerefLabel(x, 0)
}

/// Constructs a store operand which pushes to the stack.
pub fn push<L>() -> StoreOperand<L> {
    StoreOperand::Push
}

/// Constructs a store operand which discards the value.
pub fn discard<L>() -> StoreOperand<L> {
    StoreOperand::Discard
}

/// Constructs a store operand which stores to a labeled address.
pub fn storel<L>(l: L) -> StoreOperand<L> {
    StoreOperand::DerefLabel(l, 0)
}

/// Constructs a store operand which stores to a labeled address with offset.
pub fn storel_off<L>(l: L, offset: i32) -> StoreOperand<L> {
    StoreOperand::DerefLabel(l, offset)
}

/// Constructs a load operand which loads from the `m`'th local.
///
/// Unlike [`load_local`] this lets you omit the second argument. It gives a
/// correct result if and only if you have between 1 and 255 locals, so if
/// you might have 256 or more then you must use `load_local` instead.
pub fn lloc<L>(m: u32) -> LoadOperand<L> {
    load_local(m, 1)
}

/// Constructs a store operand which stores to the `m`'th local.
///
/// Unlike [`store_local`] this lets you omit the second argument. It gives a
/// correct result if and only if you have between 1 and 255 locals, so if
/// you might have 256 or more then you must use `store_local` instead.
pub fn sloc<L>(m: u32) -> StoreOperand<L> {
    store_local(m, 1)
}

/// Constructs a `MysteryString` item.
///
/// This uses [`MysteryString::from_chars_lossy`].
pub fn mystery_string<L, S>(s: &S) -> (Option<L>, Item<L>)
where
    S: AsRef<str>,
{
    (
        None,
        Item::MysteryString(MysteryString::from_chars_lossy(s.as_ref().chars())),
    )
}

/// Constructs a `Utf32String` item.
///
/// This uses [`Utf32String::from_chars_lossy`].
pub fn utf32_string<L, S>(s: &S) -> (Option<L>, Item<L>)
where
    S: AsRef<str>,
{
    (
        None,
        Item::Utf32String(Utf32String::from_chars_lossy(s.as_ref().chars())),
    )
}

/// Constructs a `CompressedString` item.
pub fn compressed_string<L, B>(b: B) -> (Option<L>, Item<L>)
where
    B: Into<Bytes>,
{
    (None, Item::CompressedString(b.into()))
}

/// Constructs a `Blob` item.
pub fn blob<L, B>(b: B) -> (Option<L>, Item<L>)
where
    B: Into<Bytes>,
{
    (None, Item::Blob(b.into()))
}

/// Constructs an `Align` item.
///
/// Panics if its argument is 0.
pub fn align<L>(alignment: u32) -> (Option<L>, Item<L>) {
    (None, Item::Align(alignment.try_into().unwrap()))
}

/// Constructs a `DecodingTable` item.
pub fn decoding_table<L>(root: DecodeNode<L>) -> (Option<L>, Item<L>) {
    (None, Item::DecodingTable(root))
}

/// Constructs a `Label` item.
pub fn label<L>(label: L) -> (Option<L>, Item<L>) {
    (None, Item::Label(label, 0))
}

/// Constructs a `Label` item with an offset.
pub fn label_off<L>(label: L, offset: i32) -> (Option<L>, Item<L>) {
    (None, Item::Label(label, offset))
}

/// Constructs an `Align` zero-item.
///
/// Panics if its argument is 0.
pub fn zalign<L>(alignment: u32) -> (Option<L>, ZeroItem) {
    (None, ZeroItem::Align(alignment.try_into().unwrap()))
}

/// Constructs a `Space` zero-item.
pub fn zspace<L>(space: u32) -> (Option<L>, ZeroItem) {
    (None, ZeroItem::Space(space))
}

// SCRIPT OUTPUT BEGINS HERE

/// Constructs an instruction item.
pub fn nop<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Nop))
}

/// Constructs an instruction item.
pub fn add<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Add(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn sub<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sub(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn mul<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mul(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn div<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Div(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn modulo<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mod(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn neg<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Neg(l1, s1)))
}

/// Constructs an instruction item.
pub fn bitand<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitand(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn bitor<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitor(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn bitxor<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitxor(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn bitnot<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitnot(l1, s1)))
}

/// Constructs an instruction item.
pub fn shiftl<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Shiftl(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn ushiftr<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ushiftr(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn sshiftr<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sshiftr(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn jump<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jump(l1)))
}

/// Constructs an instruction item.
pub fn jz<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jz(l1, LoadOperand::Branch(bt))))
}

/// Constructs an instruction item.
pub fn jnz<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jnz(l1, LoadOperand::Branch(bt))))
}

/// Constructs an instruction item.
pub fn jeq<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jeq(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jne<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jne(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jlt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jlt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jle<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jle(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jgt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jge<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jge(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jltu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jltu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jleu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jleu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jgtu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgtu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jgeu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgeu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jumpabs<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jumpabs(l1)))
}

/// Constructs an instruction item.
pub fn copy<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Copy(l1, s1)))
}

/// Constructs an instruction item.
pub fn copys<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Copys(l1, s1)))
}

/// Constructs an instruction item.
pub fn copyb<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Copyb(l1, s1)))
}

/// Constructs an instruction item.
pub fn sexs<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sexs(l1, s1)))
}

/// Constructs an instruction item.
pub fn sexb<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sexb(l1, s1)))
}

/// Constructs an instruction item.
pub fn astore<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astore(l1, l2, l3)))
}

/// Constructs an instruction item.
pub fn aload<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aload(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn astores<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astores(l1, l2, l3)))
}

/// Constructs an instruction item.
pub fn aloads<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aloads(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn astoreb<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astoreb(l1, l2, l3)))
}

/// Constructs an instruction item.
pub fn aloadb<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aloadb(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn astorebit<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astorebit(l1, l2, l3)))
}

/// Constructs an instruction item.
pub fn aloadbit<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aloadbit(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn stkcount<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkcount(s1)))
}

/// Constructs an instruction item.
pub fn stkpeek<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkpeek(l1, s1)))
}

/// Constructs an instruction item.
pub fn stkswap<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkswap))
}

/// Constructs an instruction item.
pub fn stkcopy<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkcopy(l1)))
}

/// Constructs an instruction item.
pub fn stkroll<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkroll(l1, l2)))
}

/// Constructs an instruction item.
pub fn call<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Call(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn callf<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callf(l1, s1)))
}

/// Constructs an instruction item.
pub fn callfi<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callfi(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn callfii<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callfii(l1, l2, l3, s1)))
}

/// Constructs an instruction item.
pub fn callfiii<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callfiii(l1, l2, l3, l4, s1)))
}

/// Constructs an instruction item.
pub fn ret<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Return(l1)))
}

/// Constructs an instruction item.
pub fn tailcall<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Tailcall(l1, l2)))
}

/// Constructs an instruction item.
pub fn catch<L>(s1: StoreOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Catch(s1, LoadOperand::Branch(bt))))
}

/// Constructs an instruction item.
pub fn throw<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Throw(l1, l2)))
}

/// Constructs an instruction item.
pub fn getmemsize<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Getmemsize(s1)))
}

/// Constructs an instruction item.
pub fn setmemsize<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setmemsize(l1, s1)))
}

/// Constructs an instruction item.
pub fn malloc<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Malloc(l1, s1)))
}

/// Constructs an instruction item.
pub fn mfree<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mfree(l1)))
}

/// Constructs an instruction item.
pub fn quit<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Quit))
}

/// Constructs an instruction item.
pub fn restart<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Restart))
}

/// Constructs an instruction item.
pub fn save<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Save(l1, s1)))
}

/// Constructs an instruction item.
pub fn restore<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Restore(l1, s1)))
}

/// Constructs an instruction item.
pub fn saveundo<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Saveundo(s1)))
}

/// Constructs an instruction item.
pub fn restoreundo<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Restoreundo(s1)))
}

/// Constructs an instruction item.
pub fn hasundo<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Hasundo(s1)))
}

/// Constructs an instruction item.
pub fn discardundo<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Discardundo))
}

/// Constructs an instruction item.
pub fn protect<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Protect(l1, l2)))
}

/// Constructs an instruction item.
pub fn verify<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Verify(s1)))
}

/// Constructs an instruction item.
pub fn getiosys<L>(s1: StoreOperand<L>, s2: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Getiosys(s1, s2)))
}

/// Constructs an instruction item.
pub fn setiosys<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setiosys(l1, l2)))
}

/// Constructs an instruction item.
pub fn streamchar<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamchar(l1)))
}

/// Constructs an instruction item.
pub fn streamunichar<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamunichar(l1)))
}

/// Constructs an instruction item.
pub fn streamnum<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamnum(l1)))
}

/// Constructs an instruction item.
pub fn streamstr<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamstr(l1)))
}

/// Constructs an instruction item.
pub fn getstringtbl<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Getstringtbl(s1)))
}

/// Constructs an instruction item.
pub fn setstringtbl<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setstringtbl(l1)))
}

/// Constructs an instruction item.
pub fn numtof<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Numtof(l1, s1)))
}

/// Constructs an instruction item.
pub fn ftonumz<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ftonumz(l1, s1)))
}

/// Constructs an instruction item.
pub fn ftonumn<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ftonumn(l1, s1)))
}

/// Constructs an instruction item.
pub fn fadd<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fadd(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn fsub<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fsub(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn fmul<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fmul(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn fdiv<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fdiv(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn fmod<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fmod(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn ceil<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ceil(l1, s1)))
}

/// Constructs an instruction item.
pub fn floor<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Floor(l1, s1)))
}

/// Constructs an instruction item.
pub fn sqrt<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sqrt(l1, s1)))
}

/// Constructs an instruction item.
pub fn exp<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Exp(l1, s1)))
}

/// Constructs an instruction item.
pub fn log<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Log(l1, s1)))
}

/// Constructs an instruction item.
pub fn pow<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Pow(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn sin<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sin(l1, s1)))
}

/// Constructs an instruction item.
pub fn cos<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Cos(l1, s1)))
}

/// Constructs an instruction item.
pub fn tan<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Tan(l1, s1)))
}

/// Constructs an instruction item.
pub fn asin<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Asin(l1, s1)))
}

/// Constructs an instruction item.
pub fn acos<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Acos(l1, s1)))
}

/// Constructs an instruction item.
pub fn atan<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Atan(l1, s1)))
}

/// Constructs an instruction item.
pub fn atan2<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Atan2(l1, s1)))
}

/// Constructs an instruction item.
pub fn numtod<L>(
    l1: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Numtod(l1, s1, s2)))
}

/// Constructs an instruction item.
pub fn dtonumz<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtonumz(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn dtonumn<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtonumn(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn ftod<L>(
    l1: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ftod(l1, s1, s2)))
}

/// Constructs an instruction item.
pub fn dtof<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtof(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn dadd<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dadd(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn dsub<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dsub(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn dmul<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dmul(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn ddiv<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ddiv(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn dmodr<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dmodr(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn dmodq<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dmodq(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn dceil<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dceil(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dfloor<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dfloor(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dsqrt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dsqrt(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dexp<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dexp(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dlog<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dlog(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dpow<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dpow(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn dsin<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dsin(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dcos<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dcos(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dtan<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtan(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dasin<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dasin(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn dacos<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dacos(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn datan<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Datan(l1, l2, s1, s2)))
}

/// Constructs an instruction item.
pub fn datan2<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Datan2(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an instruction item.
pub fn jisnan<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jisnan(l1, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jisinf<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jisinf(l1, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jfeq<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfeq(l1, l2, l3, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jfne<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfne(l1, l2, l3, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jflt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jflt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jfle<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfle(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jfgt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfgt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jfge<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfge(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdisnan<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdisnan(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdisinf<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdisinf(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdeq<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdeq(l1, l2, l3, l4, l5, l6, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdne<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdne(l1, l2, l3, l4, l5, l6, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdlt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdlt(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdle<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdle(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdgt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdgt(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn jdge<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdge(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an instruction item.
pub fn random<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Random(l1, s1)))
}

/// Constructs an instruction item.
pub fn setrandom<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setrandom(l1)))
}

/// Constructs an instruction item.
pub fn mzero<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mzero(l1, l2)))
}

/// Constructs an instruction item.
pub fn mcopy<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mcopy(l1, l2, l3)))
}

/// Constructs an instruction item.
pub fn linearsearch<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    l7: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Linearsearch(l1, l2, l3, l4, l5, l6, l7, s1)),
    )
}

/// Constructs an instruction item.
pub fn binarysearch<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    l7: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Binarysearch(l1, l2, l3, l4, l5, l6, l7, s1)),
    )
}

/// Constructs an instruction item.
pub fn linkedsearch<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Linkedsearch(l1, l2, l3, l4, l5, l6, s1)),
    )
}

/// Constructs an instruction item.
pub fn accelfunc<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Accelfunc(l1, l2)))
}

/// Constructs an instruction item.
pub fn accelparam<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Accelparam(l1, l2)))
}

/// Constructs an instruction item.
pub fn gestalt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Gestalt(l1, l2, s1)))
}

/// Constructs an instruction item.
pub fn debugtrap<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Debugtrap(l1)))
}

/// Constructs an instruction item.
pub fn glk<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Glk(l1, l2, s1)))
}

// SCRIPT OUTPUT ENDS HERE

/*
INSTRS = [
    ["nop"],
    ["add", "l1", "l2", "s1"],
    ["sub", "l1", "l2", "s1"],
    ["mul", "l1", "l2", "s1"],
    ["div", "l1", "l2", "s1"],
    ["mod", "l1", "l2", "s1"],
    ["neg", "l1", "s1"],
    ["bitand", "l1", "l2", "s1"],
    ["bitor", "l1", "l2", "s1"],
    ["bitxor", "l1", "l2", "s1"],
    ["bitnot", "l1", "s1"],
    ["shiftl", "l1", "l2", "s1"],
    ["ushiftr", "l1", "l2", "s1"],
    ["sshiftr", "l1", "l2", "s1"],
    ["jump", "l1"],
    ["jz", "l1", "bt"],
    ["jnz", "l1", "bt"],
    ["jeq", "l1", "l2", "bt"],
    ["jne", "l1", "l2", "bt"],
    ["jlt", "l1", "l2", "bt"],
    ["jle", "l1", "l2", "bt"],
    ["jgt", "l1", "l2", "bt"],
    ["jge", "l1", "l2", "bt"],
    ["jltu", "l1", "l2", "bt"],
    ["jleu", "l1", "l2", "bt"],
    ["jgtu", "l1", "l2", "bt"],
    ["jgeu", "l1", "l2", "bt"],
    ["jumpabs", "l1"],
    ["copy", "l1", "s1"],
    ["copys", "l1", "s1"],
    ["copyb", "l1", "s1"],
    ["sexs", "l1", "s1"],
    ["sexb", "l1", "s1"],
    ["astore", "l1", "l2", "l3"],
    ["aload", "l1", "l2", "s1"],
    ["astores", "l1", "l2", "l3"],
    ["aloads", "l1", "l2", "s1"],
    ["astoreb", "l1", "l2", "l3"],
    ["aloadb", "l1", "l2", "s1"],
    ["astorebit", "l1", "l2", "l3"],
    ["aloadbit", "l1", "l2", "s1"],
    ["stkcount", "s1"],
    ["stkpeek", "l1", "s1"],
    ["stkswap"],
    ["stkcopy", "l1"],
    ["stkroll", "l1", "l2"],
    ["call", "l1", "l2", "s1"],
    ["callf", "l1", "s1"],
    ["callfi", "l1", "l2", "s1"],
    ["callfii", "l1", "l2", "l3", "s1"],
    ["callfiii", "l1", "l2", "l3", "l4", "s1"],
    ["return", "l1"],
    ["tailcall", "l1", "l2"],
    ["catch", "s1", "bt"],
    ["throw", "l1", "l2"],
    ["getmemsize", "s1"],
    ["setmemsize", "l1", "s1"],
    ["malloc", "l1", "s1"],
    ["mfree", "l1"],
    ["quit"],
    ["restart"],
    ["save", "l1", "s1"],
    ["restore", "l1", "s1"],
    ["saveundo", "s1"],
    ["restoreundo", "s1"],
    ["hasundo", "s1"],
    ["discardundo"],
    ["protect", "l1", "l2"],
    ["verify", "s1"],
    ["getiosys", "s1", "s2"],
    ["setiosys", "l1", "l2"],
    ["streamchar", "l1"],
    ["streamunichar", "l1"],
    ["streamnum", "l1"],
    ["streamstr", "l1"],
    ["getstringtbl", "s1"],
    ["setstringtbl", "l1"],
    ["numtof", "l1", "s1"],
    ["ftonumz", "l1", "s1"],
    ["ftonumn", "l1", "s1"],
    ["fadd", "l1", "l2", "s1"],
    ["fsub", "l1", "l2", "s1"],
    ["fmul", "l1", "l2", "s1"],
    ["fdiv", "l1", "l2", "s1"],
    ["fmod", "l1", "l2", "s1"],
    ["ceil", "l1", "s1"],
    ["floor", "l1", "s1"],
    ["sqrt", "l1", "s1"],
    ["exp", "l1", "s1"],
    ["log", "l1", "s1"],
    ["pow", "l1", "l2", "s1"],
    ["sin", "l1", "s1"],
    ["cos", "l1", "s1"],
    ["tan", "l1", "s1"],
    ["asin", "l1", "s1"],
    ["acos", "l1", "s1"],
    ["atan", "l1", "s1"],
    ["atan2", "l1", "s1"],
    ["numtod", "l1", "s1", "s2"],
    ["dtonumz", "l1", "l2", "s1"],
    ["dtonumn", "l1", "l2", "s1"],
    ["ftod", "l1", "s1", "s2"],
    ["dtof", "l1", "l2", "s1"],
    ["dadd", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dsub", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dmul", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["ddiv", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dmodr", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dmodq", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dceil", "l1", "l2", "s1", "s2"],
    ["dfloor", "l1", "l2", "s1", "s2"],
    ["dsqrt", "l1", "l2", "s1", "s2"],
    ["dexp", "l1", "l2", "s1", "s2"],
    ["dlog", "l1", "l2", "s1", "s2"],
    ["dpow", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dsin", "l1", "l2", "s1", "s2"],
    ["dcos", "l1", "l2", "s1", "s2"],
    ["dtan", "l1", "l2", "s1", "s2"],
    ["dasin", "l1", "l2", "s1", "s2"],
    ["dacos", "l1", "l2", "s1", "s2"],
    ["datan", "l1", "l2", "s1", "s2"],
    ["datan2", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["jisnan", "l1", "bt"],
    ["jisinf", "l1", "bt"],
    ["jfeq", "l1", "l2", "l3", "bt"],
    ["jfne", "l1", "l2", "l3", "bt"],
    ["jflt", "l1", "l2", "bt"],
    ["jfle", "l1", "l2", "bt"],
    ["jfgt", "l1", "l2", "bt"],
    ["jfge", "l1", "l2", "bt"],
    ["jdisnan", "l1", "l2", "bt"],
    ["jdisinf", "l1", "l2", "bt"],
    ["jdeq", "l1", "l2", "l3", "l4", "l5", "l6", "bt"],
    ["jdne", "l1", "l2", "l3", "l4", "l5", "l6", "bt"],
    ["jdlt", "l1", "l2", "l3", "l4", "bt"],
    ["jdle", "l1", "l2", "l3", "l4", "bt"],
    ["jdgt", "l1", "l2", "l3", "l4", "bt"],
    ["jdge", "l1", "l2", "l3", "l4", "bt"],
    ["random", "l1", "s1"],
    ["setrandom", "l1"],
    ["mzero", "l1", "l2"],
    ["mcopy", "l1", "l2", "l3"],
    ["linearsearch", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "s1"],
    ["binarysearch", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "s1"],
    ["linkedsearch", "l1", "l2", "l3", "l4", "l5", "l6", "s1"],
    ["accelfunc", "l1", "l2"],
    ["accelparam", "l1", "l2"],
    ["gestalt", "l1", "l2", "s1"],
    ["debugtrap", "l1"],
    ["glk", "l1", "l2", "s1"],
]

for instr in INSTRS:
    op = instr[0]
    args = instr[1:]
    upper = op[0].upper() + op[1:]

    if op == "mod":
        op = "modulo"
    if op == "return":
        op = "ret"

    print("/// Constructs an instruction item.")
    print("pub fn {}<L>(".format(op), end='')
    for arg in args:
        if arg[0] == 'l':
            print("{}: LoadOperand<L>, ".format(arg), end='')
        elif arg[0] == 's':
            print("{}: StoreOperand<L>, ".format(arg), end='')
        else:
            print("{}: L, ".format(arg), end='')
    print(") -> (Option<L>, Item<L>) {", end = '')
    print("(None, Item::Instr(Instr::{}".format(upper), end = '')
    if len(args) > 0:
        print("(", end='')
        for arg in args:
            if arg == "bt":
                print("LoadOperand::OffsetLabel(bt), ", end='')
            else:
                 print("{}, ".format(arg), end='')
        print("))) }\n")
    else:
        print(")) } \n")
*/
