#![allow(clippy::too_many_arguments)]
//! Functions for concisely constructing items.
//!
//! Everything here is just a trivial wrapper around various enum variants, but
//! using it will make your code-generation code much more readable.
//!
//! * To construct a function header item: use [`fnhead_local`] or
//!   [`fnhead_stack`].
//! * To construct a load operand: use [`pop`], [`imm`], [`uimm`], [`imml`],
//!   [`imml_off`], [`derefl`], [`derefl_off`], [`lloc`] or one of the reimports
//!   [`f32_to_imm`], [`f64_to_imm`], or [`load_local`].
//! * To construct a store operand: use [`push`], [`discard`], [`storel`],
//!   [`storel_off`] [`sloc`] or the reimport [`store_local`].
//! * To construct an instruction item: use the function named for the
//!   instruction, except that `mod` is [`modulo`] and `return` is [`ret`] to
//!   avoid colliding with Rust keywords. Branch instructions, for their branch
//!   target operand, just take an `L` rather than a `LoadOperand<L>`. They have
//!   each have a variant named *instr*`_ret` which instead takes a boolean,
//!   yielding an instruction which returns a 0 or 1 from the current call frame
//!   instead of branching.
//! * To construct a string or blob: use [`mystery_string`], [`utf32_string`],
//!   [`compressed_string`], or [`blob`].
//! * To construct a label item: use [`label`] or [`label_off`].
//! * To construct an alignment item: use [`align`].
//! * To construct a decoding table item: use [`decoding_table`].
//! * To construct a zero-item: use [`zspace`] or [`zalign`].
//!
//! Item constructors return a pair `(Option<L>, Item<L>)` in which the option
//! is `None`. To add a label, call `.label(l)` on it via the [`AddLabel`]
//! trait. Likewise goes for zero-item constructors.

// The instruction constructors were generated by a Python script, because that
// was easier than a one-off proc macro. The source to the script is in comments
// at the bottom of the module.

use crate::{cast::CastSign, DecodeNode, LabelRef};
pub use crate::{f32_to_imm, f64_to_imm};
use crate::{
    CallingConvention, Instr, Item, LoadOperand, MysteryString, StoreOperand, Utf32String, ZeroItem,
};

use bytes::Bytes;

/// Add a label to an item.
///
/// Call `.label(l)` on an `(Option<L>, Item<L>)` pair to change the
/// first part of the tuple to `Some(l)`.
pub trait AddLabel {
    /// The type of label operated upon.
    type Label;

    /// Add the given label.
    fn label(self, label: Self::Label) -> Self;
}

impl<L> AddLabel for (Option<L>, Item<L>) {
    type Label = L;
    fn label(self, label: L) -> Self {
        (Some(label), self.1)
    }
}

impl<L> AddLabel for (Option<L>, ZeroItem) {
    type Label = L;
    fn label(self, label: L) -> Self {
        (Some(label), self.1)
    }
}

/// Constructs a function header item with the `ArgsInLocals` calling convention.
pub fn fnhead_local<L>(nlocals: u32) -> (Option<L>, Item<L>) {
    (
        None,
        Item::FnHeader(CallingConvention::ArgsInLocals, nlocals),
    )
}

/// Constructs a function header item with the `ArgsOnStack` calling convention.
pub fn fnhead_stack<L>(nlocals: u32) -> (Option<L>, Item<L>) {
    (
        None,
        Item::FnHeader(CallingConvention::ArgsOnStack, nlocals),
    )
}

/// Constructs a load operand that pops from the stack.
pub fn pop<L>() -> LoadOperand<L> {
    LoadOperand::Pop
}

/// Constructs an immediate load operand.
pub fn imm<L>(x: i32) -> LoadOperand<L> {
    LoadOperand::Imm(x)
}

/// Constructs an unsigned immediate load operand.
pub fn uimm<L>(x: u32) -> LoadOperand<L> {
    LoadOperand::Imm(x.cast_sign())
}

/// Constructs an immedate load operand from a label.
pub fn imml<L>(x: L) -> LoadOperand<L> {
    LoadOperand::ImmLabel(LabelRef(x, 0), 0)
}

/// Constructs an immedate load operand from a label and offset.
pub fn imml_off<L>(x: L, offset: i32) -> LoadOperand<L> {
    LoadOperand::ImmLabel(LabelRef(x, offset), 0)
}

/// Constructs an immedate load operand from a label, offset, and right-shift.
pub fn imml_off_shift<L>(x: L, offset: i32, shift: u8) -> LoadOperand<L> {
    LoadOperand::ImmLabel(LabelRef(x, offset), shift)
}

/// Constructs a load operand which derefernces a label.
pub fn derefl<L>(x: L) -> LoadOperand<L> {
    LoadOperand::DerefLabel(LabelRef(x, 0))
}

/// Constructs a load operand which derefernces a label and offset.
pub fn derefl_off<L>(x: L, offset: i32) -> LoadOperand<L> {
    LoadOperand::DerefLabel(LabelRef(x, offset))
}

/// Constructs a store operand which pushes to the stack.
pub fn push<L>() -> StoreOperand<L> {
    StoreOperand::Push
}

/// Constructs a store operand which discards the value.
pub fn discard<L>() -> StoreOperand<L> {
    StoreOperand::Discard
}

/// Constructs a store operand which stores to a labeled address.
pub fn storel<L>(l: L) -> StoreOperand<L> {
    StoreOperand::DerefLabel(LabelRef(l, 0))
}

/// Constructs a store operand which stores to a labeled address with offset.
pub fn storel_off<L>(l: L, offset: i32) -> StoreOperand<L> {
    StoreOperand::DerefLabel(LabelRef(l, offset))
}

/// Constructs a load operand which loads from the `n`'th local.
pub fn lloc<L>(n: u32) -> LoadOperand<L> {
    LoadOperand::FrameAddr(4*n)
}

/// Constructs a store operand which stores to the `n`'th local.
pub fn sloc<L>(n: u32) -> StoreOperand<L> {
    StoreOperand::FrameAddr(4*n)
}

/// Constructs a `MysteryString` item.
///
/// This uses [`MysteryString::from_chars_lossy`].
pub fn mystery_string<L, S>(s: &S) -> (Option<L>, Item<L>)
where
    S: AsRef<str>,
{
    (
        None,
        Item::MysteryString(MysteryString::from_chars_lossy(s.as_ref().chars())),
    )
}

/// Constructs a `Utf32String` item.
///
/// This uses [`Utf32String::from_chars_lossy`].
pub fn utf32_string<L, S>(s: &S) -> (Option<L>, Item<L>)
where
    S: AsRef<str>,
{
    (
        None,
        Item::Utf32String(Utf32String::from_chars_lossy(s.as_ref().chars())),
    )
}

/// Constructs a `CompressedString` item.
pub fn compressed_string<L, B>(b: B) -> (Option<L>, Item<L>)
where
    B: Into<Bytes>,
{
    (None, Item::CompressedString(b.into()))
}

/// Constructs a `Blob` item.
pub fn blob<L, B>(b: B) -> (Option<L>, Item<L>)
where
    B: Into<Bytes>,
{
    (None, Item::Blob(b.into()))
}

/// Constructs an `Align` item.
///
/// Panics if its argument is 0.
pub fn align<L>(alignment: u32) -> (Option<L>, Item<L>) {
    (None, Item::Align(alignment.try_into().unwrap()))
}

/// Constructs a `DecodingTable` item.
pub fn decoding_table<L>(root: DecodeNode<L>) -> (Option<L>, Item<L>) {
    (None, Item::DecodingTable(root))
}

/// Constructs a `Label` item.
pub fn label<L>(label: L) -> (Option<L>, Item<L>) {
    (None, Item::Label(LabelRef(label, 0), 0))
}

/// Constructs a `Label` item with an offset.
pub fn label_off<L>(label: L, offset: i32) -> (Option<L>, Item<L>) {
    (None, Item::Label(LabelRef(label, offset), 0))
}

/// Constructs a `Label` item with an offset and right shift.
pub fn label_off_shift<L>(label: L, offset: i32, shift: u8) -> (Option<L>, Item<L>) {
    (None, Item::Label(LabelRef(label, offset), shift))
}

/// Constructs an `Align` zero-item.
///
/// Panics if its argument is 0.
pub fn zalign<L>(alignment: u32) -> (Option<L>, ZeroItem) {
    (None, ZeroItem::Align(alignment.try_into().unwrap()))
}

/// Constructs a `Space` zero-item.
pub fn zspace<L>(space: u32) -> (Option<L>, ZeroItem) {
    (None, ZeroItem::Space(space))
}

// SCRIPT OUTPUT BEGINS HERE

/// Constructs an item for the `nop` instruction.
pub fn nop<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Nop))
}

/// Constructs an item for the `add` instruction.
pub fn add<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Add(l1, l2, s1)))
}

/// Constructs an item for the `sub` instruction.
pub fn sub<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sub(l1, l2, s1)))
}

/// Constructs an item for the `mul` instruction.
pub fn mul<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mul(l1, l2, s1)))
}

/// Constructs an item for the `div` instruction.
pub fn div<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Div(l1, l2, s1)))
}

/// Constructs an item for the `mod` instruction.
pub fn modulo<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mod(l1, l2, s1)))
}

/// Constructs an item for the `neg` instruction.
pub fn neg<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Neg(l1, s1)))
}

/// Constructs an item for the `bitand` instruction.
pub fn bitand<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitand(l1, l2, s1)))
}

/// Constructs an item for the `bitor` instruction.
pub fn bitor<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitor(l1, l2, s1)))
}

/// Constructs an item for the `bitxor` instruction.
pub fn bitxor<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitxor(l1, l2, s1)))
}

/// Constructs an item for the `bitnot` instruction.
pub fn bitnot<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Bitnot(l1, s1)))
}

/// Constructs an item for the `shiftl` instruction.
pub fn shiftl<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Shiftl(l1, l2, s1)))
}

/// Constructs an item for the `ushiftr` instruction.
pub fn ushiftr<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ushiftr(l1, l2, s1)))
}

/// Constructs an item for the `sshiftr` instruction.
pub fn sshiftr<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sshiftr(l1, l2, s1)))
}

/// Constructs an item for the `jump` instruction.
pub fn jump<L>(bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jump(LoadOperand::Branch(bt))))
}

/// Constructs an item for the `jump` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jump_ret<L>(bt: bool) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jump(LoadOperand::Imm(bt.into()))))
}

/// Constructs an item for the `jz` instruction.
pub fn jz<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jz(l1, LoadOperand::Branch(bt))))
}

/// Constructs an item for the `jz` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jz_ret<L>(l1: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jz(l1, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jnz` instruction.
pub fn jnz<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jnz(l1, LoadOperand::Branch(bt))))
}

/// Constructs an item for the `jnz` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jnz_ret<L>(l1: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jnz(l1, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jeq` instruction.
pub fn jeq<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jeq(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jeq` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jeq_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jeq(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jne` instruction.
pub fn jne<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jne(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jne` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jne_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jne(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jlt` instruction.
pub fn jlt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jlt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jlt` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jlt_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jlt(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jle` instruction.
pub fn jle<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jle(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jle` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jle_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jle(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jgt` instruction.
pub fn jgt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jgt` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jgt_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgt(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jge` instruction.
pub fn jge<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jge(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jge` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jge_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jge(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jltu` instruction.
pub fn jltu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jltu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jltu` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jltu_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jltu(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jleu` instruction.
pub fn jleu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jleu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jleu` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jleu_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jleu(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jgtu` instruction.
pub fn jgtu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgtu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jgtu` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jgtu_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgtu(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jgeu` instruction.
pub fn jgeu<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgeu(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jgeu` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jgeu_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jgeu(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jumpabs` instruction.
pub fn jumpabs<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Jumpabs(l1)))
}

/// Constructs an item for the `copy` instruction.
pub fn copy<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Copy(l1, s1)))
}

/// Constructs an item for the `copys` instruction.
pub fn copys<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Copys(l1, s1)))
}

/// Constructs an item for the `copyb` instruction.
pub fn copyb<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Copyb(l1, s1)))
}

/// Constructs an item for the `sexs` instruction.
pub fn sexs<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sexs(l1, s1)))
}

/// Constructs an item for the `sexb` instruction.
pub fn sexb<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sexb(l1, s1)))
}

/// Constructs an item for the `astore` instruction.
pub fn astore<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astore(l1, l2, l3)))
}

/// Constructs an item for the `aload` instruction.
pub fn aload<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aload(l1, l2, s1)))
}

/// Constructs an item for the `astores` instruction.
pub fn astores<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astores(l1, l2, l3)))
}

/// Constructs an item for the `aloads` instruction.
pub fn aloads<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aloads(l1, l2, s1)))
}

/// Constructs an item for the `astoreb` instruction.
pub fn astoreb<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astoreb(l1, l2, l3)))
}

/// Constructs an item for the `aloadb` instruction.
pub fn aloadb<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aloadb(l1, l2, s1)))
}

/// Constructs an item for the `astorebit` instruction.
pub fn astorebit<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Astorebit(l1, l2, l3)))
}

/// Constructs an item for the `aloadbit` instruction.
pub fn aloadbit<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Aloadbit(l1, l2, s1)))
}

/// Constructs an item for the `stkcount` instruction.
pub fn stkcount<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkcount(s1)))
}

/// Constructs an item for the `stkpeek` instruction.
pub fn stkpeek<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkpeek(l1, s1)))
}

/// Constructs an item for the `stkswap` instruction.
pub fn stkswap<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkswap))
}

/// Constructs an item for the `stkcopy` instruction.
pub fn stkcopy<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkcopy(l1)))
}

/// Constructs an item for the `stkroll` instruction.
pub fn stkroll<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Stkroll(l1, l2)))
}

/// Constructs an item for the `call` instruction.
pub fn call<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Call(l1, l2, s1)))
}

/// Constructs an item for the `callf` instruction.
pub fn callf<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callf(l1, s1)))
}

/// Constructs an item for the `callfi` instruction.
pub fn callfi<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callfi(l1, l2, s1)))
}

/// Constructs an item for the `callfii` instruction.
pub fn callfii<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callfii(l1, l2, l3, s1)))
}

/// Constructs an item for the `callfiii` instruction.
pub fn callfiii<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Callfiii(l1, l2, l3, l4, s1)))
}

/// Constructs an item for the `return` instruction.
pub fn ret<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Return(l1)))
}

/// Constructs an item for the `tailcall` instruction.
pub fn tailcall<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Tailcall(l1, l2)))
}

/// Constructs an item for the `catch` instruction.
pub fn catch<L>(s1: StoreOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Catch(s1, LoadOperand::Branch(bt))))
}

/// Constructs an item for the `catch` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn catch_ret<L>(s1: StoreOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Catch(s1, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `throw` instruction.
pub fn throw<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Throw(l1, l2)))
}

/// Constructs an item for the `getmemsize` instruction.
pub fn getmemsize<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Getmemsize(s1)))
}

/// Constructs an item for the `setmemsize` instruction.
pub fn setmemsize<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setmemsize(l1, s1)))
}

/// Constructs an item for the `malloc` instruction.
pub fn malloc<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Malloc(l1, s1)))
}

/// Constructs an item for the `mfree` instruction.
pub fn mfree<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mfree(l1)))
}

/// Constructs an item for the `quit` instruction.
pub fn quit<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Quit))
}

/// Constructs an item for the `restart` instruction.
pub fn restart<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Restart))
}

/// Constructs an item for the `save` instruction.
pub fn save<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Save(l1, s1)))
}

/// Constructs an item for the `restore` instruction.
pub fn restore<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Restore(l1, s1)))
}

/// Constructs an item for the `saveundo` instruction.
pub fn saveundo<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Saveundo(s1)))
}

/// Constructs an item for the `restoreundo` instruction.
pub fn restoreundo<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Restoreundo(s1)))
}

/// Constructs an item for the `hasundo` instruction.
pub fn hasundo<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Hasundo(s1)))
}

/// Constructs an item for the `discardundo` instruction.
pub fn discardundo<L>() -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Discardundo))
}

/// Constructs an item for the `protect` instruction.
pub fn protect<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Protect(l1, l2)))
}

/// Constructs an item for the `verify` instruction.
pub fn verify<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Verify(s1)))
}

/// Constructs an item for the `getiosys` instruction.
pub fn getiosys<L>(s1: StoreOperand<L>, s2: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Getiosys(s1, s2)))
}

/// Constructs an item for the `setiosys` instruction.
pub fn setiosys<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setiosys(l1, l2)))
}

/// Constructs an item for the `streamchar` instruction.
pub fn streamchar<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamchar(l1)))
}

/// Constructs an item for the `streamunichar` instruction.
pub fn streamunichar<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamunichar(l1)))
}

/// Constructs an item for the `streamnum` instruction.
pub fn streamnum<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamnum(l1)))
}

/// Constructs an item for the `streamstr` instruction.
pub fn streamstr<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Streamstr(l1)))
}

/// Constructs an item for the `getstringtbl` instruction.
pub fn getstringtbl<L>(s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Getstringtbl(s1)))
}

/// Constructs an item for the `setstringtbl` instruction.
pub fn setstringtbl<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setstringtbl(l1)))
}

/// Constructs an item for the `numtof` instruction.
pub fn numtof<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Numtof(l1, s1)))
}

/// Constructs an item for the `ftonumz` instruction.
pub fn ftonumz<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ftonumz(l1, s1)))
}

/// Constructs an item for the `ftonumn` instruction.
pub fn ftonumn<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ftonumn(l1, s1)))
}

/// Constructs an item for the `fadd` instruction.
pub fn fadd<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fadd(l1, l2, s1)))
}

/// Constructs an item for the `fsub` instruction.
pub fn fsub<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fsub(l1, l2, s1)))
}

/// Constructs an item for the `fmul` instruction.
pub fn fmul<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fmul(l1, l2, s1)))
}

/// Constructs an item for the `fdiv` instruction.
pub fn fdiv<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fdiv(l1, l2, s1)))
}

/// Constructs an item for the `fmod` instruction.
pub fn fmod<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Fmod(l1, l2, s1)))
}

/// Constructs an item for the `ceil` instruction.
pub fn ceil<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ceil(l1, s1)))
}

/// Constructs an item for the `floor` instruction.
pub fn floor<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Floor(l1, s1)))
}

/// Constructs an item for the `sqrt` instruction.
pub fn sqrt<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sqrt(l1, s1)))
}

/// Constructs an item for the `exp` instruction.
pub fn exp<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Exp(l1, s1)))
}

/// Constructs an item for the `log` instruction.
pub fn log<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Log(l1, s1)))
}

/// Constructs an item for the `pow` instruction.
pub fn pow<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Pow(l1, l2, s1)))
}

/// Constructs an item for the `sin` instruction.
pub fn sin<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Sin(l1, s1)))
}

/// Constructs an item for the `cos` instruction.
pub fn cos<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Cos(l1, s1)))
}

/// Constructs an item for the `tan` instruction.
pub fn tan<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Tan(l1, s1)))
}

/// Constructs an item for the `asin` instruction.
pub fn asin<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Asin(l1, s1)))
}

/// Constructs an item for the `acos` instruction.
pub fn acos<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Acos(l1, s1)))
}

/// Constructs an item for the `atan` instruction.
pub fn atan<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Atan(l1, s1)))
}

/// Constructs an item for the `atan2` instruction.
pub fn atan2<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Atan2(l1, s1)))
}

/// Constructs an item for the `numtod` instruction.
pub fn numtod<L>(
    l1: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Numtod(l1, s1, s2)))
}

/// Constructs an item for the `dtonumz` instruction.
pub fn dtonumz<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtonumz(l1, l2, s1)))
}

/// Constructs an item for the `dtonumn` instruction.
pub fn dtonumn<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtonumn(l1, l2, s1)))
}

/// Constructs an item for the `ftod` instruction.
pub fn ftod<L>(
    l1: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ftod(l1, s1, s2)))
}

/// Constructs an item for the `dtof` instruction.
pub fn dtof<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtof(l1, l2, s1)))
}

/// Constructs an item for the `dadd` instruction.
pub fn dadd<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dadd(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `dsub` instruction.
pub fn dsub<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dsub(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `dmul` instruction.
pub fn dmul<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dmul(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `ddiv` instruction.
pub fn ddiv<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Ddiv(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `dmodr` instruction.
pub fn dmodr<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dmodr(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `dmodq` instruction.
pub fn dmodq<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dmodq(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `dceil` instruction.
pub fn dceil<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dceil(l1, l2, s1, s2)))
}

/// Constructs an item for the `dfloor` instruction.
pub fn dfloor<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dfloor(l1, l2, s1, s2)))
}

/// Constructs an item for the `dsqrt` instruction.
pub fn dsqrt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dsqrt(l1, l2, s1, s2)))
}

/// Constructs an item for the `dexp` instruction.
pub fn dexp<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dexp(l1, l2, s1, s2)))
}

/// Constructs an item for the `dlog` instruction.
pub fn dlog<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dlog(l1, l2, s1, s2)))
}

/// Constructs an item for the `dpow` instruction.
pub fn dpow<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dpow(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `dsin` instruction.
pub fn dsin<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dsin(l1, l2, s1, s2)))
}

/// Constructs an item for the `dcos` instruction.
pub fn dcos<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dcos(l1, l2, s1, s2)))
}

/// Constructs an item for the `dtan` instruction.
pub fn dtan<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dtan(l1, l2, s1, s2)))
}

/// Constructs an item for the `dasin` instruction.
pub fn dasin<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dasin(l1, l2, s1, s2)))
}

/// Constructs an item for the `dacos` instruction.
pub fn dacos<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Dacos(l1, l2, s1, s2)))
}

/// Constructs an item for the `datan` instruction.
pub fn datan<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Datan(l1, l2, s1, s2)))
}

/// Constructs an item for the `datan2` instruction.
pub fn datan2<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    s1: StoreOperand<L>,
    s2: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Datan2(l1, l2, l3, l4, s1, s2)))
}

/// Constructs an item for the `jisnan` instruction.
pub fn jisnan<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jisnan(l1, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jisnan` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jisnan_ret<L>(l1: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jisnan(l1, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jisinf` instruction.
pub fn jisinf<L>(l1: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jisinf(l1, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jisinf` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jisinf_ret<L>(l1: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jisinf(l1, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jfeq` instruction.
pub fn jfeq<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfeq(l1, l2, l3, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jfeq` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jfeq_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfeq(l1, l2, l3, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jfne` instruction.
pub fn jfne<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfne(l1, l2, l3, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jfne` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jfne_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfne(l1, l2, l3, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jflt` instruction.
pub fn jflt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jflt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jflt` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jflt_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jflt(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jfle` instruction.
pub fn jfle<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfle(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jfle` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jfle_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfle(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jfgt` instruction.
pub fn jfgt<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfgt(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jfgt` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jfgt_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfgt(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jfge` instruction.
pub fn jfge<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfge(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jfge` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jfge_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jfge(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jdisnan` instruction.
pub fn jdisnan<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdisnan(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdisnan` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdisnan_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdisnan(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jdisinf` instruction.
pub fn jdisinf<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: L) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdisinf(l1, l2, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdisinf` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdisinf_ret<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, bt: bool) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdisinf(l1, l2, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jdeq` instruction.
pub fn jdeq<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdeq(l1, l2, l3, l4, l5, l6, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdeq` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdeq_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdeq(
            l1,
            l2,
            l3,
            l4,
            l5,
            l6,
            LoadOperand::Imm(bt.into()),
        )),
    )
}

/// Constructs an item for the `jdne` instruction.
pub fn jdne<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdne(l1, l2, l3, l4, l5, l6, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdne` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdne_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdne(
            l1,
            l2,
            l3,
            l4,
            l5,
            l6,
            LoadOperand::Imm(bt.into()),
        )),
    )
}

/// Constructs an item for the `jdlt` instruction.
pub fn jdlt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdlt(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdlt` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdlt_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdlt(l1, l2, l3, l4, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jdle` instruction.
pub fn jdle<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdle(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdle` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdle_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdle(l1, l2, l3, l4, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jdgt` instruction.
pub fn jdgt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdgt(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdgt` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdgt_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdgt(l1, l2, l3, l4, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `jdge` instruction.
pub fn jdge<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: L,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdge(l1, l2, l3, l4, LoadOperand::Branch(bt))),
    )
}

/// Constructs an item for the `jdge` instruction, with a branch operand that returns 0 or 1 instead of branching
pub fn jdge_ret<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    bt: bool,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Jdge(l1, l2, l3, l4, LoadOperand::Imm(bt.into()))),
    )
}

/// Constructs an item for the `random` instruction.
pub fn random<L>(l1: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Random(l1, s1)))
}

/// Constructs an item for the `setrandom` instruction.
pub fn setrandom<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Setrandom(l1)))
}

/// Constructs an item for the `mzero` instruction.
pub fn mzero<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mzero(l1, l2)))
}

/// Constructs an item for the `mcopy` instruction.
pub fn mcopy<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Mcopy(l1, l2, l3)))
}

/// Constructs an item for the `linearsearch` instruction.
pub fn linearsearch<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    l7: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Linearsearch(l1, l2, l3, l4, l5, l6, l7, s1)),
    )
}

/// Constructs an item for the `binarysearch` instruction.
pub fn binarysearch<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    l7: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Binarysearch(l1, l2, l3, l4, l5, l6, l7, s1)),
    )
}

/// Constructs an item for the `linkedsearch` instruction.
pub fn linkedsearch<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    l3: LoadOperand<L>,
    l4: LoadOperand<L>,
    l5: LoadOperand<L>,
    l6: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (
        None,
        Item::Instr(Instr::Linkedsearch(l1, l2, l3, l4, l5, l6, s1)),
    )
}

/// Constructs an item for the `accelfunc` instruction.
pub fn accelfunc<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Accelfunc(l1, l2)))
}

/// Constructs an item for the `accelparam` instruction.
pub fn accelparam<L>(l1: LoadOperand<L>, l2: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Accelparam(l1, l2)))
}

/// Constructs an item for the `gestalt` instruction.
pub fn gestalt<L>(
    l1: LoadOperand<L>,
    l2: LoadOperand<L>,
    s1: StoreOperand<L>,
) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Gestalt(l1, l2, s1)))
}

/// Constructs an item for the `debugtrap` instruction.
pub fn debugtrap<L>(l1: LoadOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Debugtrap(l1)))
}

/// Constructs an item for the `glk` instruction.
pub fn glk<L>(l1: LoadOperand<L>, l2: LoadOperand<L>, s1: StoreOperand<L>) -> (Option<L>, Item<L>) {
    (None, Item::Instr(Instr::Glk(l1, l2, s1)))
}

// SCRIPT OUTPUT ENDS HERE

/*
INSTRS = [
    ["nop"],
    ["add", "l1", "l2", "s1"],
    ["sub", "l1", "l2", "s1"],
    ["mul", "l1", "l2", "s1"],
    ["div", "l1", "l2", "s1"],
    ["mod", "l1", "l2", "s1"],
    ["neg", "l1", "s1"],
    ["bitand", "l1", "l2", "s1"],
    ["bitor", "l1", "l2", "s1"],
    ["bitxor", "l1", "l2", "s1"],
    ["bitnot", "l1", "s1"],
    ["shiftl", "l1", "l2", "s1"],
    ["ushiftr", "l1", "l2", "s1"],
    ["sshiftr", "l1", "l2", "s1"],
    ["jump", "bt"],
    ["jz", "l1", "bt"],
    ["jnz", "l1", "bt"],
    ["jeq", "l1", "l2", "bt"],
    ["jne", "l1", "l2", "bt"],
    ["jlt", "l1", "l2", "bt"],
    ["jle", "l1", "l2", "bt"],
    ["jgt", "l1", "l2", "bt"],
    ["jge", "l1", "l2", "bt"],
    ["jltu", "l1", "l2", "bt"],
    ["jleu", "l1", "l2", "bt"],
    ["jgtu", "l1", "l2", "bt"],
    ["jgeu", "l1", "l2", "bt"],
    ["jumpabs", "l1"],
    ["copy", "l1", "s1"],
    ["copys", "l1", "s1"],
    ["copyb", "l1", "s1"],
    ["sexs", "l1", "s1"],
    ["sexb", "l1", "s1"],
    ["astore", "l1", "l2", "l3"],
    ["aload", "l1", "l2", "s1"],
    ["astores", "l1", "l2", "l3"],
    ["aloads", "l1", "l2", "s1"],
    ["astoreb", "l1", "l2", "l3"],
    ["aloadb", "l1", "l2", "s1"],
    ["astorebit", "l1", "l2", "l3"],
    ["aloadbit", "l1", "l2", "s1"],
    ["stkcount", "s1"],
    ["stkpeek", "l1", "s1"],
    ["stkswap"],
    ["stkcopy", "l1"],
    ["stkroll", "l1", "l2"],
    ["call", "l1", "l2", "s1"],
    ["callf", "l1", "s1"],
    ["callfi", "l1", "l2", "s1"],
    ["callfii", "l1", "l2", "l3", "s1"],
    ["callfiii", "l1", "l2", "l3", "l4", "s1"],
    ["return", "l1"],
    ["tailcall", "l1", "l2"],
    ["catch", "s1", "bt"],
    ["throw", "l1", "l2"],
    ["getmemsize", "s1"],
    ["setmemsize", "l1", "s1"],
    ["malloc", "l1", "s1"],
    ["mfree", "l1"],
    ["quit"],
    ["restart"],
    ["save", "l1", "s1"],
    ["restore", "l1", "s1"],
    ["saveundo", "s1"],
    ["restoreundo", "s1"],
    ["hasundo", "s1"],
    ["discardundo"],
    ["protect", "l1", "l2"],
    ["verify", "s1"],
    ["getiosys", "s1", "s2"],
    ["setiosys", "l1", "l2"],
    ["streamchar", "l1"],
    ["streamunichar", "l1"],
    ["streamnum", "l1"],
    ["streamstr", "l1"],
    ["getstringtbl", "s1"],
    ["setstringtbl", "l1"],
    ["numtof", "l1", "s1"],
    ["ftonumz", "l1", "s1"],
    ["ftonumn", "l1", "s1"],
    ["fadd", "l1", "l2", "s1"],
    ["fsub", "l1", "l2", "s1"],
    ["fmul", "l1", "l2", "s1"],
    ["fdiv", "l1", "l2", "s1"],
    ["fmod", "l1", "l2", "s1"],
    ["ceil", "l1", "s1"],
    ["floor", "l1", "s1"],
    ["sqrt", "l1", "s1"],
    ["exp", "l1", "s1"],
    ["log", "l1", "s1"],
    ["pow", "l1", "l2", "s1"],
    ["sin", "l1", "s1"],
    ["cos", "l1", "s1"],
    ["tan", "l1", "s1"],
    ["asin", "l1", "s1"],
    ["acos", "l1", "s1"],
    ["atan", "l1", "s1"],
    ["atan2", "l1", "s1"],
    ["numtod", "l1", "s1", "s2"],
    ["dtonumz", "l1", "l2", "s1"],
    ["dtonumn", "l1", "l2", "s1"],
    ["ftod", "l1", "s1", "s2"],
    ["dtof", "l1", "l2", "s1"],
    ["dadd", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dsub", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dmul", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["ddiv", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dmodr", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dmodq", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dceil", "l1", "l2", "s1", "s2"],
    ["dfloor", "l1", "l2", "s1", "s2"],
    ["dsqrt", "l1", "l2", "s1", "s2"],
    ["dexp", "l1", "l2", "s1", "s2"],
    ["dlog", "l1", "l2", "s1", "s2"],
    ["dpow", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["dsin", "l1", "l2", "s1", "s2"],
    ["dcos", "l1", "l2", "s1", "s2"],
    ["dtan", "l1", "l2", "s1", "s2"],
    ["dasin", "l1", "l2", "s1", "s2"],
    ["dacos", "l1", "l2", "s1", "s2"],
    ["datan", "l1", "l2", "s1", "s2"],
    ["datan2", "l1", "l2", "l3", "l4", "s1", "s2"],
    ["jisnan", "l1", "bt"],
    ["jisinf", "l1", "bt"],
    ["jfeq", "l1", "l2", "l3", "bt"],
    ["jfne", "l1", "l2", "l3", "bt"],
    ["jflt", "l1", "l2", "bt"],
    ["jfle", "l1", "l2", "bt"],
    ["jfgt", "l1", "l2", "bt"],
    ["jfge", "l1", "l2", "bt"],
    ["jdisnan", "l1", "l2", "bt"],
    ["jdisinf", "l1", "l2", "bt"],
    ["jdeq", "l1", "l2", "l3", "l4", "l5", "l6", "bt"],
    ["jdne", "l1", "l2", "l3", "l4", "l5", "l6", "bt"],
    ["jdlt", "l1", "l2", "l3", "l4", "bt"],
    ["jdle", "l1", "l2", "l3", "l4", "bt"],
    ["jdgt", "l1", "l2", "l3", "l4", "bt"],
    ["jdge", "l1", "l2", "l3", "l4", "bt"],
    ["random", "l1", "s1"],
    ["setrandom", "l1"],
    ["mzero", "l1", "l2"],
    ["mcopy", "l1", "l2", "l3"],
    ["linearsearch", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "s1"],
    ["binarysearch", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "s1"],
    ["linkedsearch", "l1", "l2", "l3", "l4", "l5", "l6", "s1"],
    ["accelfunc", "l1", "l2"],
    ["accelparam", "l1", "l2"],
    ["gestalt", "l1", "l2", "s1"],
    ["debugtrap", "l1"],
    ["glk", "l1", "l2", "s1"],
]

for instr in INSTRS:
    op = instr[0]
    args = instr[1:]
    upper = op[0].upper() + op[1:]

    print("/// Constructs an item for the `{}` instruction.".format(op))

    if op == "mod":
        op = "modulo"
    if op == "return":
        op = "ret"

    print("pub fn {}<L>(".format(op), end='')
    for arg in args:
        if arg[0] == 'l':
            print("{}: LoadOperand<L>, ".format(arg), end='')
        elif arg[0] == 's':
            print("{}: StoreOperand<L>, ".format(arg), end='')
        else:
            print("{}: L, ".format(arg), end='')
    print(") -> (Option<L>, Item<L>) {", end = '')
    print("(None, Item::Instr(Instr::{}".format(upper), end = '')
    if len(args) > 0:
        print("(", end='')
        for arg in args:
            if arg == "bt":
                print("LoadOperand::Branch(bt), ", end='')
            else:
                 print("{}, ".format(arg), end='')
        print("))) }\n")
    else:
        print(")) } \n")

    if len(args) > 0 and args[-1] == "bt":
        print("/// Constructs an item for the `{}` instruction, with a branch operand that returns 0 or 1 instead of branching".format(op))
        print("pub fn {}_ret<L>(".format(op), end='')
        for arg in args:
            if arg[0] == 'l':
                print("{}: LoadOperand<L>, ".format(arg), end='')
            elif arg[0] == 's':
                print("{}: StoreOperand<L>, ".format(arg), end='')
            else:
                print("{}: bool, ".format(arg), end='')
        print(") -> (Option<L>, Item<L>) {", end = '')
        print("(None, Item::Instr(Instr::{}(".format(upper), end = '')
        for arg in args:
            if arg == "bt":
                print("LoadOperand::Imm(bt.into()), ", end='')
            else:
                 print("{}, ".format(arg), end='')
        print("))) }\n")
*/
